-- phpMyAdmin SQL Dump
-- version 4.9.2
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1
-- Generation Time: Dec 02, 2020 at 11:16 PM
-- Server version: 10.4.11-MariaDB
-- PHP Version: 7.2.26

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `algorithms`
--

-- --------------------------------------------------------

--
-- Table structure for table `algo`
--

CREATE TABLE `algo` (
  `algo_id` int(11) NOT NULL,
  `grp_id` int(10) NOT NULL,
  `name` varchar(30) NOT NULL,
  `definition` varchar(1000) NOT NULL,
  `image` varchar(100) NOT NULL,
  `explaination` varchar(2000) NOT NULL,
  `python` varchar(5000) NOT NULL,
  `cpp` varchar(7000) NOT NULL,
  `java` varchar(7000) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `algo`
--

INSERT INTO `algo` (`algo_id`, `grp_id`, `name`, `definition`, `image`, `explaination`, `python`, `cpp`, `java`) VALUES
(1, 1, 'BFS', 'Breadth-first search (BFS) is an important graph search algorithm that is used to solve many problems including finding the shortest path in a graph and solving puzzle games (such as Rubik\'s Cubes). ', 'bfs.gif', 'A sketch of a very common BFS implementation is as follows:<br>\r\nPut the starting node on a queue and marked it as visited<br>\r\nWhile the queue is not empty:<br>\r\n	pop off the node at the head of the queue\r\n\r\n	<br>If it is the node we are searching for Then exit and return the node\r\n\r\n	<br>For all of the unvisited neighbors:\r\n		mark the neighbour as visited\r\n		put the neighbour in the queue\r\n\r\n<br>If we get here, the node is not reachable from the starting node, BFS failed', 'from collections import defaultdict \r\n  \r\n# This class represents a directed graph \r\n# using adjacency list representation \r\nclass Graph: \r\n  \r\n    # Constructor \r\n    def __init__(self): \r\n  \r\n        # default dictionary to store graph \r\n        self.graph = defaultdict(list) \r\n  \r\n    # function to add an edge to graph \r\n    def addEdge(self,u,v): \r\n        self.graph[u].append(v) \r\n  \r\n    # Function to print a BFS of graph \r\n    def BFS(self, s): \r\n  \r\n        # Mark all the vertices as not visited \r\n        visited = [False] * (len(self.graph)) \r\n  \r\n        # Create a queue for BFS \r\n        queue = [] \r\n  \r\n        # Mark the source node as  \r\n        # visited and enqueue it \r\n        queue.append(s) \r\n        visited[s] = True\r\n  \r\n        while queue: \r\n  \r\n            # Dequeue a vertex from  \r\n            # queue and print it \r\n            s = queue.pop(0) \r\n            print (s, end = \" \") \r\n  \r\n            # Get all adjacent vertices of the \r\n            # dequeued vertex s. If a adjacent \r\n            # has not been visited, then mark it \r\n            # visited and enqueue it \r\n            for i in self.graph[s]: \r\n                if visited[i] == False: \r\n                    queue.append(i) \r\n                    visited[i] = True\r\n  \r\n# Driver code \r\n  \r\n# Create a graph given in \r\n# the above diagram \r\ng = Graph() \r\ng.addEdge(0, 1) \r\ng.addEdge(0, 2) \r\ng.addEdge(1, 2) \r\ng.addEdge(2, 0) \r\ng.addEdge(2, 3) \r\ng.addEdge(3, 3) \r\n  \r\nprint (\"Following is Breadth First Traversal\"\r\n                  \" (starting from vertex 2)\") \r\ng.BFS(2) \r\n  ', '\r\n// Program to print BFS traversal from a given \r\n// source vertex. BFS(int s) traverses vertices  \r\n// reachable from s. \r\n#include<iostream> \r\n#include <list> \r\n  \r\nusing namespace std; \r\n  \r\n// This class represents a directed graph using \r\n// adjacency list representation \r\nclass Graph \r\n{ \r\n    int V;    // No. of vertices \r\n  \r\n    // Pointer to an array containing adjacency \r\n    // lists \r\n    list<int> *adj;    \r\npublic: \r\n    Graph(int V);  // Constructor \r\n  \r\n    // function to add an edge to graph \r\n    void addEdge(int v, int w);  \r\n  \r\n    // prints BFS traversal from a given source s \r\n    void BFS(int s);   \r\n}; \r\n  \r\nGraph::Graph(int V) \r\n{ \r\n    this->V = V; \r\n    adj = new list<int>[V]; \r\n} \r\n  \r\nvoid Graph::addEdge(int v, int w) \r\n{ \r\n    adj[v].push_back(w); // Add w to v’s list. \r\n} \r\n  \r\nvoid Graph::BFS(int s) \r\n{ \r\n    // Mark all the vertices as not visited \r\n    bool *visited = new bool[V]; \r\n    for(int i = 0; i < V; i++) \r\n        visited[i] = false; \r\n  \r\n    // Create a queue for BFS \r\n    list<int> queue; \r\n  \r\n    // Mark the current node as visited and enqueue it \r\n    visited[s] = true; \r\n    queue.push_back(s); \r\n  \r\n    // \'i\' will be used to get all adjacent \r\n    // vertices of a vertex \r\n    list<int>::iterator i; \r\n  \r\n    while(!queue.empty()) \r\n    { \r\n        // Dequeue a vertex from queue and print it \r\n        s = queue.front(); \r\n        cout << s << \" \"; \r\n        queue.pop_front(); \r\n  \r\n        // Get all adjacent vertices of the dequeued \r\n        // vertex s. If a adjacent has not been visited,  \r\n        // then mark it visited and enqueue it \r\n        for (i = adj[s].begin(); i != adj[s].end(); ++i) \r\n        { \r\n            if (!visited[*i]) \r\n            { \r\n                visited[*i] = true; \r\n                queue.push_back(*i); \r\n            } \r\n        } \r\n    } \r\n} \r\n  \r\n// Driver program to test methods of graph class \r\nint main() \r\n{ \r\n    // Create a graph given in the above diagram \r\n    Graph g(4); \r\n    g.addEdge(0, 1); \r\n    g.addEdge(0, 2); \r\n    g.addEdge(1, 2); \r\n    g.addEdge(2, 0); \r\n    g.addEdge(2, 3); \r\n    g.addEdge(3, 3); \r\n  \r\n    cout << \"Following is Breadth First Traversal \"\r\n         << \"(starting from vertex 2) \\n\"; \r\n    g.BFS(2); \r\n  \r\n    return 0; \r\n}', '// BFS(int s) traverses vertices reachable from s. \r\nimport java.io.*; \r\nimport java.util.*; \r\n  \r\n// This class represents a directed graph using adjacency list \r\n// representation \r\nclass Graph \r\n{ \r\n    private int V;   // No. of vertices \r\n    private LinkedList<Integer> adj[]; //Adjacency Lists \r\n  \r\n    // Constructor \r\n    Graph(int v) \r\n    { \r\n        V = v; \r\n        adj = new LinkedList[v]; \r\n        for (int i=0; i<v; ++i) \r\n            adj[i] = new LinkedList(); \r\n    } \r\n  \r\n    // Function to add an edge into the graph \r\n    void addEdge(int v,int w) \r\n    { \r\n        adj[v].add(w); \r\n    } \r\n  \r\n    // prints BFS traversal from a given source s \r\n    void BFS(int s) \r\n    { \r\n        // Mark all the vertices as not visited(By default \r\n        // set as false) \r\n        boolean visited[] = new boolean[V]; \r\n  \r\n        // Create a queue for BFS \r\n        LinkedList<Integer> queue = new LinkedList<Integer>(); \r\n  \r\n        // Mark the current node as visited and enqueue it \r\n        visited[s]=true; \r\n        queue.add(s); \r\n  \r\n        while (queue.size() != 0) \r\n        { \r\n            // Dequeue a vertex from queue and print it \r\n            s = queue.poll(); \r\n            System.out.print(s+\" \"); \r\n  \r\n            // Get all adjacent vertices of the dequeued vertex s \r\n            // If a adjacent has not been visited, then mark it \r\n            // visited and enqueue it \r\n            Iterator<Integer> i = adj[s].listIterator(); \r\n            while (i.hasNext()) \r\n            { \r\n                int n = i.next(); \r\n                if (!visited[n]) \r\n                { \r\n                    visited[n] = true; \r\n                    queue.add(n); \r\n                } \r\n            } \r\n        } \r\n    } \r\n  \r\n    // Driver method to \r\n    public static void main(String args[]) \r\n    { \r\n        Graph g = new Graph(4); \r\n  \r\n        g.addEdge(0, 1); \r\n        g.addEdge(0, 2); \r\n        g.addEdge(1, 2); \r\n        g.addEdge(2, 0); \r\n        g.addEdge(2, 3); \r\n        g.addEdge(3, 3); \r\n  \r\n        System.out.println(\"Following is Breadth First Traversal \"+ \r\n                           \"(starting from vertex 2)\"); \r\n  \r\n        g.BFS(2); \r\n    } \r\n} '),
(2, 1, 'DFS', 'Depth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration.', 'dfs.gif', 'Depth-first search is an algorithm for traversing or searching tree or graph data structures.<br> The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.<br> So the basic idea is to start from the root or any arbitrary node and mark the node and move to the adjacent unmarked node and continue this loop until there is no unmarked adjacent node. <br>Then backtrack and check for other unmarked nodes and traverse them. Finally print the nodes in the path.', 'from collections import defaultdict \r\n  \r\n# This class represents a directed graph using \r\n# adjacency list representation \r\nclass Graph: \r\n  \r\n    # Constructor \r\n    def __init__(self): \r\n  \r\n        # default dictionary to store graph \r\n        self.graph = defaultdict(list) \r\n  \r\n    # function to add an edge to graph \r\n    def addEdge(self, u, v): \r\n        self.graph[u].append(v) \r\n  \r\n    # A function used by DFS \r\n    def DFSUtil(self, v, visited): \r\n  \r\n        # Mark the current node as visited  \r\n        # and print it \r\n        visited[v] = True\r\n        print(v, end = \' \') \r\n  \r\n        # Recur for all the vertices  \r\n        # adjacent to this vertex \r\n        for i in self.graph[v]: \r\n            if visited[i] == False: \r\n                self.DFSUtil(i, visited) \r\n  \r\n    # The function to do DFS traversal. It uses \r\n    # recursive DFSUtil() \r\n    def DFS(self, v): \r\n  \r\n        # Mark all the vertices as not visited \r\n        visited = [False] * (max(self.graph)+1) \r\n  \r\n        # Call the recursive helper function  \r\n        # to print DFS traversal \r\n        self.DFSUtil(v, visited) \r\n  \r\n# Driver code \r\n  \r\n# Create a graph given  \r\n# in the above diagram \r\ng = Graph() \r\ng.addEdge(0, 1) \r\ng.addEdge(0, 2) \r\ng.addEdge(1, 2) \r\ng.addEdge(2, 0) \r\ng.addEdge(2, 3) \r\ng.addEdge(3, 3) \r\n  \r\nprint(\"Following is DFS from (starting from vertex 2)\") \r\ng.DFS(2) ', '#include<bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n// Graph class represents a directed graph \r\n// using adjacency list representation \r\nclass Graph \r\n{ \r\n    int V;    // No. of vertices \r\n  \r\n    // Pointer to an array containing \r\n    // adjacency lists \r\n    list<int> *adj; \r\n  \r\n    // A recursive function used by DFS \r\n    void DFSUtil(int v, bool visited[]); \r\npublic: \r\n    Graph(int V);   // Constructor \r\n  \r\n    // function to add an edge to graph \r\n    void addEdge(int v, int w); \r\n  \r\n    // DFS traversal of the vertices \r\n    // reachable from v \r\n    void DFS(int v); \r\n}; \r\n  \r\nGraph::Graph(int V) \r\n{ \r\n    this->V = V; \r\n    adj = new list<int>[V]; \r\n} \r\n  \r\nvoid Graph::addEdge(int v, int w) \r\n{ \r\n    adj[v].push_back(w); // Add w to v’s list. \r\n} \r\n  \r\nvoid Graph::DFSUtil(int v, bool visited[]) \r\n{ \r\n    // Mark the current node as visited and \r\n    // print it \r\n    visited[v] = true; \r\n    cout << v << \" \"; \r\n  \r\n    // Recur for all the vertices adjacent \r\n    // to this vertex \r\n    list<int>::iterator i; \r\n    for (i = adj[v].begin(); i != adj[v].end(); ++i) \r\n        if (!visited[*i]) \r\n            DFSUtil(*i, visited); \r\n} \r\n  \r\n// DFS traversal of the vertices reachable from v. \r\n// It uses recursive DFSUtil() \r\nvoid Graph::DFS(int v) \r\n{ \r\n    // Mark all the vertices as not visited \r\n    bool *visited = new bool[V]; \r\n    for (int i = 0; i < V; i++) \r\n        visited[i] = false; \r\n  \r\n    // Call the recursive helper function \r\n    // to print DFS traversal \r\n    DFSUtil(v, visited); \r\n} \r\n  \r\n// Driver code \r\nint main() \r\n{ \r\n    // Create a graph given in the above diagram \r\n    Graph g(4); \r\n    g.addEdge(0, 1); \r\n    g.addEdge(0, 2); \r\n    g.addEdge(1, 2); \r\n    g.addEdge(2, 0); \r\n    g.addEdge(2, 3); \r\n    g.addEdge(3, 3); \r\n  \r\n    cout << \"Following is Depth First Traversal\"\r\n            \" (starting from vertex 2) \\n\"; \r\n    g.DFS(2); \r\n  \r\n    return 0; \r\n} ', 'import java.io.*; \r\nimport java.util.*; \r\n  \r\n// This class represents a directed graph using adjacency list \r\n// representation \r\nclass Graph \r\n{ \r\n    private int V;   // No. of vertices \r\n  \r\n    // Array  of lists for Adjacency List Representation \r\n    private LinkedList<Integer> adj[]; \r\n  \r\n    // Constructor \r\n    @SuppressWarnings(\"unchecked\") \r\n    Graph(int v) \r\n    { \r\n        V = v; \r\n        adj = new LinkedList[v]; \r\n        for (int i=0; i<v; ++i) \r\n            adj[i] = new LinkedList(); \r\n    } \r\n  \r\n    //Function to add an edge into the graph \r\n    void addEdge(int v, int w) \r\n    { \r\n        adj[v].add(w);  // Add w to v\'s list. \r\n    } \r\n  \r\n    // A function used by DFS \r\n    void DFSUtil(int v,boolean visited[]) \r\n    { \r\n        // Mark the current node as visited and print it \r\n        visited[v] = true; \r\n        System.out.print(v+\" \"); \r\n  \r\n        // Recur for all the vertices adjacent to this vertex \r\n        Iterator<Integer> i = adj[v].listIterator(); \r\n        while (i.hasNext()) \r\n        { \r\n            int n = i.next(); \r\n            if (!visited[n]) \r\n                DFSUtil(n, visited); \r\n        } \r\n    } \r\n  \r\n    // The function to do DFS traversal. It uses recursive DFSUtil() \r\n    void DFS(int v) \r\n    { \r\n        // Mark all the vertices as not visited(set as \r\n        // false by default in java) \r\n        boolean visited[] = new boolean[V]; \r\n  \r\n        // Call the recursive helper function to print DFS traversal \r\n        DFSUtil(v, visited); \r\n    } \r\n  \r\n    public static void main(String args[]) \r\n    { \r\n        Graph g = new Graph(4); \r\n  \r\n        g.addEdge(0, 1); \r\n        g.addEdge(0, 2); \r\n        g.addEdge(1, 2); \r\n        g.addEdge(2, 0); \r\n        g.addEdge(2, 3); \r\n        g.addEdge(3, 3); \r\n  \r\n        System.out.println(\"Following is Depth First Traversal \"+ \r\n                           \"(starting from vertex 2)\"); \r\n  \r\n        g.DFS(2); \r\n    } \r\n}'),
(3, 1, 'Dijkstra', 'One algorithm for finding the shortest path from a starting node to a target node in a weighted graph is Dijkstra’s algorithm. The algorithm creates a tree of shortest paths from the starting vertex, the source, to all other points in the graph.', 'dijkstra2.gif', 'Below are the detailed steps used in Dijkstra’s algorithm to find the shortest path from a single source vertex to all other vertices in the given graph.<br>\r\nAlgorithm<br>\r\n1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in shortest path tree, i.e., whose minimum distance from source is calculated and finalized. Initially, this set is empty.<br>\r\n2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE. Assign distance value as 0 for the source vertex so that it is picked first.<br>\r\n3) While sptSet doesn’t include all vertices<br>\r\n….a) Pick a vertex u which is not there in sptSet and has minimum distance value.<br>\r\n….b) Include u to sptSet.<br>\r\n….c) Update distance value of all adjacent vertices of u. To update the distance values, iterate through all adjacent vertices. For every adjacent vertex v, if sum of distance value of u (from source) and weight of edge u-v, is less than the distance value of v, then update the distance value of v.', '# Library for INT_MAX \r\nimport sys \r\n  \r\nclass Graph(): \r\n  \r\n    def __init__(self, vertices): \r\n        self.V = vertices \r\n        self.graph = [[0 for column in range(vertices)]  \r\n                    for row in range(vertices)] \r\n  \r\n    def printSolution(self, dist): \r\n        print \"Vertex \\tDistance from Source\"\r\n        for node in range(self.V): \r\n            print node, \"\\t\", dist[node] \r\n  \r\n    # A utility function to find the vertex with  \r\n    # minimum distance value, from the set of vertices  \r\n    # not yet included in shortest path tree \r\n    def minDistance(self, dist, sptSet): \r\n  \r\n        # Initilaize minimum distance for next node \r\n        min = sys.maxint \r\n  \r\n        # Search not nearest vertex not in the  \r\n        # shortest path tree \r\n        for v in range(self.V): \r\n            if dist[v] < min and sptSet[v] == False: \r\n                min = dist[v] \r\n                min_index = v \r\n  \r\n        return min_index \r\n  \r\n    # Funtion that implements Dijkstra\'s single source  \r\n    # shortest path algorithm for a graph represented  \r\n    # using adjacency matrix representation \r\n    def dijkstra(self, src): \r\n  \r\n        dist = [sys.maxint] * self.V \r\n        dist[src] = 0\r\n        sptSet = [False] * self.V \r\n  \r\n        for cout in range(self.V): \r\n  \r\n            # Pick the minimum distance vertex from  \r\n            # the set of vertices not yet processed.  \r\n            # u is always equal to src in first iteration \r\n            u = self.minDistance(dist, sptSet) \r\n  \r\n            # Put the minimum distance vertex in the  \r\n            # shotest path tree \r\n            sptSet[u] = True\r\n  \r\n            # Update dist value of the adjacent vertices  \r\n            # of the picked vertex only if the current  \r\n            # distance is greater than new distance and \r\n            # the vertex in not in the shotest path tree \r\n            for v in range(self.V): \r\n                if self.graph[u][v] > 0 and sptSet[v] == False and \\ \r\n                dist[v] > dist[u] + self.graph[u][v]: \r\n                        dist[v] = dist[u] + self.graph[u][v] \r\n  \r\n        self.printSolution(dist) \r\n  \r\n# Driver program \r\ng = Graph(9) \r\ng.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0], \r\n        [4, 0, 8, 0, 0, 0, 0, 11, 0], \r\n        [0, 8, 0, 7, 0, 4, 0, 0, 2], \r\n        [0, 0, 7, 0, 9, 14, 0, 0, 0], \r\n        [0, 0, 0, 9, 0, 10, 0, 0, 0], \r\n        [0, 0, 4, 14, 10, 0, 2, 0, 0], \r\n        [0, 0, 0, 0, 0, 2, 0, 1, 6], \r\n        [8, 11, 0, 0, 0, 0, 1, 0, 7], \r\n        [0, 0, 2, 0, 0, 0, 6, 7, 0] \r\n        ]; \r\n  \r\ng.dijkstra(0); ', '#include <limits.h> \r\n#include <stdio.h> \r\n  \r\n// Number of vertices in the graph \r\n#define V 9 \r\n  \r\n// A utility function to find the vertex with minimum distance value, from \r\n// the set of vertices not yet included in shortest path tree \r\nint minDistance(int dist[], bool sptSet[]) \r\n{ \r\n    // Initialize min value \r\n    int min = INT_MAX, min_index; \r\n  \r\n    for (int v = 0; v < V; v++) \r\n        if (sptSet[v] == false && dist[v] <= min) \r\n            min = dist[v], min_index = v; \r\n  \r\n    return min_index; \r\n} \r\n  \r\n// A utility function to print the constructed distance array \r\nvoid printSolution(int dist[]) \r\n{ \r\n    printf(\"Vertex \\t\\t Distance from Source\\n\"); \r\n    for (int i = 0; i < V; i++) \r\n        printf(\"%d \\t\\t %d\\n\", i, dist[i]); \r\n} \r\n  \r\n// Function that implements Dijkstra\'s single source shortest path algorithm \r\n// for a graph represented using adjacency matrix representation \r\nvoid dijkstra(int graph[V][V], int src) \r\n{ \r\n    int dist[V]; // The output array.  dist[i] will hold the shortest \r\n    // distance from src to i \r\n  \r\n    bool sptSet[V]; // sptSet[i] will be true if vertex i is included in shortest \r\n    // path tree or shortest distance from src to i is finalized \r\n  \r\n    // Initialize all distances as INFINITE and stpSet[] as false \r\n    for (int i = 0; i < V; i++) \r\n        dist[i] = INT_MAX, sptSet[i] = false; \r\n  \r\n    // Distance of source vertex from itself is always 0 \r\n    dist[src] = 0; \r\n  \r\n    // Find shortest path for all vertices \r\n    for (int count = 0; count < V - 1; count++) { \r\n        // Pick the minimum distance vertex from the set of vertices not \r\n        // yet processed. u is always equal to src in the first iteration. \r\n        int u = minDistance(dist, sptSet); \r\n  \r\n        // Mark the picked vertex as processed \r\n        sptSet[u] = true; \r\n  \r\n        // Update dist value of the adjacent vertices of the picked vertex. \r\n        for (int v = 0; v < V; v++) \r\n  \r\n            // Update dist[v] only if is not in sptSet, there is an edge from \r\n            // u to v, and total weight of path from src to  v through u is \r\n            // smaller than current value of dist[v] \r\n            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX \r\n                && dist[u] + graph[u][v] < dist[v]) \r\n                dist[v] = dist[u] + graph[u][v]; \r\n    } \r\n  \r\n    // print the constructed distance array \r\n    printSolution(dist); \r\n} \r\n  \r\n// driver program to test above function \r\nint main() \r\n{ \r\n    /* Let us create the example graph discussed above */\r\n    int graph[V][V] = { { 0, 4, 0, 0, 0, 0, 0, 8, 0 }, \r\n                        { 4, 0, 8, 0, 0, 0, 0, 11, 0 }, \r\n                        { 0, 8, 0, 7, 0, 4, 0, 0, 2 }, \r\n                        { 0, 0, 7, 0, 9, 14, 0, 0, 0 }, \r\n                        { 0, 0, 0, 9, 0, 10, 0, 0, 0 }, \r\n                        { 0, 0, 4, 14, 10, 0, 2, 0, 0 }, \r\n                        { 0, 0, 0, 0, 0, 2, 0, 1, 6 }, \r\n                        { 8, 11, 0, 0, 0, 0, 1, 0, 7 }, \r\n                        { 0, 0, 2, 0, 0, 0, 6, 7, 0 } }; \r\n  \r\n    dijkstra(graph, 0); \r\n  \r\n    return 0; \r\n}', 'import java.util.*; \r\nimport java.lang.*; \r\nimport java.io.*; \r\n  \r\nclass ShortestPath { \r\n    // A utility function to find the vertex with minimum distance value, \r\n    // from the set of vertices not yet included in shortest path tree \r\n    static final int V = 9; \r\n    int minDistance(int dist[], Boolean sptSet[]) \r\n    { \r\n        // Initialize min value \r\n        int min = Integer.MAX_VALUE, min_index = -1; \r\n  \r\n        for (int v = 0; v < V; v++) \r\n            if (sptSet[v] == false && dist[v] <= min) { \r\n                min = dist[v]; \r\n                min_index = v; \r\n            } \r\n  \r\n        return min_index; \r\n    } \r\n  \r\n    // A utility function to print the constructed distance array \r\n    void printSolution(int dist[]) \r\n    { \r\n        System.out.println(\"Vertex \\t\\t Distance from Source\"); \r\n        for (int i = 0; i < V; i++) \r\n            System.out.println(i + \" \\t\\t \" + dist[i]); \r\n    } \r\n  \r\n    // Function that implements Dijkstra\'s single source shortest path \r\n    // algorithm for a graph represented using adjacency matrix \r\n    // representation \r\n    void dijkstra(int graph[][], int src) \r\n    { \r\n        int dist[] = new int[V]; // The output array. dist[i] will hold \r\n        // the shortest distance from src to i \r\n  \r\n        // sptSet[i] will true if vertex i is included in shortest \r\n        // path tree or shortest distance from src to i is finalized \r\n        Boolean sptSet[] = new Boolean[V]; \r\n  \r\n        // Initialize all distances as INFINITE and stpSet[] as false \r\n        for (int i = 0; i < V; i++) { \r\n            dist[i] = Integer.MAX_VALUE; \r\n            sptSet[i] = false; \r\n        } \r\n  \r\n        // Distance of source vertex from itself is always 0 \r\n        dist[src] = 0; \r\n  \r\n        // Find shortest path for all vertices \r\n        for (int count = 0; count < V - 1; count++) { \r\n            // Pick the minimum distance vertex from the set of vertices \r\n            // not yet processed. u is always equal to src in first \r\n            // iteration. \r\n            int u = minDistance(dist, sptSet); \r\n  \r\n            // Mark the picked vertex as processed \r\n            sptSet[u] = true; \r\n  \r\n            // Update dist value of the adjacent vertices of the \r\n            // picked vertex. \r\n            for (int v = 0; v < V; v++) \r\n  \r\n                // Update dist[v] only if is not in sptSet, there is an \r\n                // edge from u to v, and total weight of path from src to \r\n                // v through u is smaller than current value of dist[v] \r\n                if (!sptSet[v] && graph[u][v] != 0 && dist[u] != Integer.MAX_VALUE && dist[u] + graph[u][v] < dist[v]) \r\n                    dist[v] = dist[u] + graph[u][v]; \r\n        } \r\n  \r\n        // print the constructed distance array \r\n        printSolution(dist); \r\n    } \r\n  \r\n    // Driver method \r\n    public static void main(String[] args) \r\n    { \r\n        /* Let us create the example graph discussed above */\r\n        int graph[][] = new int[][] { { 0, 4, 0, 0, 0, 0, 0, 8, 0 }, \r\n                                      { 4, 0, 8, 0, 0, 0, 0, 11, 0 }, \r\n                                      { 0, 8, 0, 7, 0, 4, 0, 0, 2 }, \r\n                                      { 0, 0, 7, 0, 9, 14, 0, 0, 0 }, \r\n                                      { 0, 0, 0, 9, 0, 10, 0, 0, 0 }, \r\n                                      { 0, 0, 4, 14, 10, 0, 2, 0, 0 }, \r\n                                      { 0, 0, 0, 0, 0, 2, 0, 1, 6 }, \r\n                                      { 8, 11, 0, 0, 0, 0, 1, 0, 7 }, \r\n                                      { 0, 0, 2, 0, 0, 0, 6, 7, 0 } }; \r\n        ShortestPath t = new ShortestPath(); \r\n        t.dijkstra(graph, 0); \r\n    } \r\n}'),
(4, 1, 'A star', 'A* (pronounced as \"A star\") is a computer algorithm that is widely used in pathfinding and graph traversal. The algorithm efficiently plots a walkable path between multiple nodes, or points, on the graph', 'astar2.gif', 'Consider a square grid having many obstacles and we are given a starting cell and a target cell. We want to reach the target cell (if possible) from the starting cell as quickly as possible.<br> Here A* Search Algorithm comes to the rescue.\r\n<br>\r\nWhat A* Search Algorithm does is that at each step it picks the node according to a value-‘f’ which is a parameter equal to the sum of two other parameters – ‘g’ and ‘h’. At each step it picks the node/cell having the lowest ‘f’, and process that node/cell.<br>\r\n\r\nWe define ‘g’ and ‘h’ as simply as possible below<br>\r\n\r\ng = the movement cost to move from the starting point to a given square on the grid, following the path generated to get there.<br>\r\nh = the estimated movement cost to move from that given square on the grid to the final destination. <br>This is often referred to as the heuristic, which is nothing but a kind of smart guess.<br> We really don’t know the actual distance until we find the path, because all sorts of things can be in the way (walls, water, etc.', 'class Node():\r\n    def __init__(self, parent=None, position=None):\r\n        self.parent = parent\r\n        self.position = position\r\n        self.g = 0\r\n        self.h = 0\r\n        self.f = 0\r\n    def __eq__(self, other):\r\n        return self.position == other.position\r\ndef astar(maze, start, end):\r\n    start_node = Node(None, start)\r\n    start_node.g = start_node.h = start_node.f = 0\r\n    end_node = Node(None, end)\r\n    end_node.g = end_node.h = end_node.f = 0\r\n    open_list = []\r\n    closed_list = []\r\n    open_list.append(start_node)\r\n    while len(open_list) > 0:\r\n        current_node = open_list[0]\r\n        current_index = 0\r\n        for index, item in enumerate(open_list):\r\n            if item.f < current_node.f:\r\n                current_node = item\r\n                current_index = index\r\n        open_list.pop(current_index)\r\n        closed_list.append(current_node)\r\n        if current_node == end_node:\r\n            path = []\r\n            current = current_node\r\n            while current is not None:\r\n                path.append(current.position)\r\n                current = current.parent\r\n            return path[::-1]\r\n        children = []\r\n        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\r\n            node_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])\r\n            if node_position[0] > (len(maze) - 1) or node_position[0] < 0 or node_position[1] > (\r\n                    len(maze[len(maze) - 1]) - 1) or node_position[1] < 0:\r\n                continue\r\n            if maze[node_position[0]][node_position[1]] != 0:\r\n                continue\r\n            new_node = Node(current_node, node_position)\r\n            children.append(new_node)\r\n        for child in children:\r\n            for closed_child in closed_list:\r\n                if child == closed_child:\r\n                    continue\r\n            child.g = current_node.g + 1\r\n            child.h = ((child.position[0] - end_node.position[0]) ** 2) + (\r\n                    (child.position[1] - end_node.position[1]) ** 2)\r\n            child.f = child.g + child.h\r\n            for open_node in open_list:\r\n                if child == open_node and child.g > open_node.g:\r\n                    continue\r\n            open_list.append(child)\r\ndef main():\r\n    maze = [[0, 0, 0, 0, 1, 0],\r\n            [0, 0, 0, 0, 1, 0],\r\n            [0, 0, 0, 0, 1, 0],\r\n            [0, 0, 0, 0, 1, 0],\r\n            [0, 0, 0, 0, 1, 0],\r\n            [0, 0, 0, 0, 0, 0]]\r\n    graph = [[0, 1, 0, 0, 0, 0],\r\n             [1, 0, 1, 0, 1, 0],\r\n             [0, 1, 0, 0, 0, 1],\r\n             [0, 0, 0, 0, 1, 0],\r\n             [0, 1, 0, 1, 0, 0],\r\n             [0, 0, 1, 0, 0, 0]\r\n             ]\r\n    start = (0, 0)\r\n    end = (5, 5)\r\n    end1 = (5, 5)\r\n    path = astar(maze, start, end)\r\n    print(path)\r\n    path1 = astar(graph, start, end1)\r\n    print(path1)\r\nif __name__ == \'__main__\':\r\n    main()', '#include <list>\r\n#include <algorithm>\r\n#include <iostream>\r\n \r\nclass point {\r\npublic:\r\n    point( int a = 0, int b = 0 ) { x = a; y = b; }\r\n    bool operator ==( const point& o ) { return o.x == x && o.y == y; }\r\n    point operator +( const point& o ) { return point( o.x + x, o.y + y ); }\r\n    int x, y;\r\n};\r\n \r\nclass map {\r\npublic:\r\n    map() {\r\n        char t[8][8] = {\r\n            {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0},\r\n            {0, 0, 0, 0, 1, 1, 1, 0}, {0, 0, 1, 0, 0, 0, 1, 0},\r\n            {0, 0, 1, 0, 0, 0, 1, 0}, {0, 0, 1, 1, 1, 1, 1, 0},\r\n            {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}\r\n        };\r\n        w = h = 8;\r\n        for( int r = 0; r < h; r++ )\r\n            for( int s = 0; s < w; s++ )\r\n                m[s][r] = t[r][s];\r\n    }\r\n    int operator() ( int x, int y ) { return m[x][y]; }\r\n    char m[8][8];\r\n    int w, h;\r\n};\r\n \r\nclass node {\r\npublic:\r\n    bool operator == (const node& o ) { return pos == o.pos; }\r\n    bool operator == (const point& o ) { return pos == o; }\r\n    bool operator < (const node& o ) { return dist + cost < o.dist + o.cost; }\r\n    point pos, parent;\r\n    int dist, cost;\r\n};\r\n \r\nclass aStar {\r\npublic:\r\n    aStar() {\r\n        neighbours[0] = point( -1, -1 ); neighbours[1] = point(  1, -1 );\r\n        neighbours[2] = point( -1,  1 ); neighbours[3] = point(  1,  1 );\r\n        neighbours[4] = point(  0, -1 ); neighbours[5] = point( -1,  0 );\r\n        neighbours[6] = point(  0,  1 ); neighbours[7] = point(  1,  0 );\r\n    }\r\n \r\n    int calcDist( point& p ){\r\n        // need a better heuristic\r\n        int x = end.x - p.x, y = end.y - p.y;\r\n        return( x * x + y * y );\r\n    }\r\n \r\n    bool isValid( point& p ) {\r\n        return ( p.x >-1 && p.y > -1 && p.x < m.w && p.y < m.h );\r\n    }\r\n \r\n    bool existPoint( point& p, int cost ) {\r\n        std::list<node>::iterator i;\r\n        i = std::find( closed.begin(), closed.end(), p );\r\n        if( i != closed.end() ) {\r\n            if( ( *i ).cost + ( *i ).dist < cost ) return true;\r\n            else { closed.erase( i ); return false; }\r\n        }\r\n        i = std::find( open.begin(), open.end(), p );\r\n        if( i != open.end() ) {\r\n            if( ( *i ).cost + ( *i ).dist < cost ) return true;\r\n            else { open.erase( i ); return false; }\r\n        }\r\n        return false;\r\n    }\r\n \r\n    bool fillOpen( node& n ) {\r\n        int stepCost, nc, dist;\r\n        point neighbour;\r\n \r\n        for( int x = 0; x < 8; x++ ) {\r\n            // one can make diagonals have different cost\r\n            stepCost = x < 4 ? 1 : 1;\r\n            neighbour = n.pos + neighbours[x];\r\n            if( neighbour == end ) return true;\r\n \r\n            if( isValid( neighbour ) && m( neighbour.x, neighbour.y ) != 1 ) {\r\n                nc = stepCost + n.cost;\r\n                dist = calcDist( neighbour );\r\n                if( !existPoint( neighbour, nc + dist ) ) {\r\n                    node m;\r\n                    m.cost = nc; m.dist = dist;\r\n                    m.pos = neighbour; \r\n                    m.parent = n.pos;\r\n                    open.push_back( m );\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n \r\n    bool search( point& s, point& e, map& mp ) {\r\n        node n; end = e; start = s; m = mp;\r\n        n.cost = 0; n.pos = s; n.parent = 0; n.dist = calcDist( s ); \r\n        open.push_back( n );\r\n        while( !open.empty() ) {\r\n            //open.sort();\r\n            node n = open.front();\r\n            open.pop_front();\r\n            closed.push_back( n );\r\n            if( fillOpen( n ) ) return true;\r\n        }\r\n        return false;\r\n    }\r\n \r\n    int path( std::list<point>& path ) {\r\n        path.push_front( end );\r\n        int cost = 1 + closed.back().cost; \r\n        path.push_front( closed.back().pos );\r\n        point parent = closed.back().parent;\r\n \r\n        for( std::list<node>::reverse_iterator i = closed.rbegin(); i != closed.rend(); i++ ) {\r\n            if( ( *i ).pos == parent && !( ( *i ).pos == start ) ) {\r\n                path.push_front( ( *i ).pos );\r\n                parent = ( *i ).parent;\r\n            }\r\n        }\r\n        path.push_front( start );\r\n        return cost;\r\n    }\r\n \r\n    map m; point end, start;\r\n    point neighbours[8];\r\n    std::list<node> open;\r\n    std::list<node> closed;\r\n};\r\n \r\nint main( int argc, char* argv[] ) {\r\n    map m;\r\n    point s, e( 7, 7 );\r\n    aStar as;\r\n \r\n    if( as.search( s, e, m ) ) {\r\n        std::list<point> path;\r\n        int c = as.path( path );\r\n        for( int y = -1; y < 9; y++ ) {\r\n            for( int x = -1; x < 9; x++ ) {\r\n                if( x < 0 || y < 0 || x > 7 || y > 7 || m( x, y ) == 1 )\r\n                    std::cout << char(0xdb);\r\n                else {\r\n                    if( std::find( path.begin(), path.end(), point( x, y ) )!= path.end() )\r\n                        std::cout << \"x\";\r\n                    else std::cout << \".\";\r\n                }\r\n            }\r\n            std::cout << \"\\n\";\r\n        }\r\n \r\n   ', 'package astar;\r\n \r\nimport java.util.List;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n \r\nclass AStar {\r\n    private final List<Node> open;\r\n    private final List<Node> closed;\r\n    private final List<Node> path;\r\n    private final int[][] maze;\r\n    private Node now;\r\n    private final int xstart;\r\n    private final int ystart;\r\n    private int xend, yend;\r\n    private final boolean diag;\r\n \r\n    // Node class for convienience\r\n    static class Node implements Comparable {\r\n        public Node parent;\r\n        public int x, y;\r\n        public double g;\r\n        public double h;\r\n        Node(Node parent, int xpos, int ypos, double g, double h) {\r\n            this.parent = parent;\r\n            this.x = xpos;\r\n            this.y = ypos;\r\n            this.g = g;\r\n            this.h = h;\r\n       }\r\n       // Compare by f value (g + h)\r\n       @Override\r\n       public int compareTo(Object o) {\r\n           Node that = (Node) o;\r\n           return (int)((this.g + this.h) - (that.g + that.h));\r\n       }\r\n   }\r\n \r\n    AStar(int[][] maze, int xstart, int ystart, boolean diag) {\r\n        this.open = new ArrayList<>();\r\n        this.closed = new ArrayList<>();\r\n        this.path = new ArrayList<>();\r\n        this.maze = maze;\r\n        this.now = new Node(null, xstart, ystart, 0, 0);\r\n        this.xstart = xstart;\r\n        this.ystart = ystart;\r\n        this.diag = diag;\r\n    }\r\n    /*\r\n    ** Finds path to xend/yend or returns null\r\n    **\r\n    ** @param (int) xend coordinates of the target position\r\n    ** @param (int) yend\r\n    ** @return (List<Node> | null) the path\r\n    */\r\n    public List<Node> findPathTo(int xend, int yend) {\r\n        this.xend = xend;\r\n        this.yend = yend;\r\n        this.closed.add(this.now);\r\n        addNeigborsToOpenList();\r\n        while (this.now.x != this.xend || this.now.y != this.yend) {\r\n            if (this.open.isEmpty()) { // Nothing to examine\r\n                return null;\r\n            }\r\n            this.now = this.open.get(0); // get first node (lowest f score)\r\n            this.open.remove(0); // remove it\r\n            this.closed.add(this.now); // and add to the closed\r\n            addNeigborsToOpenList();\r\n        }\r\n        this.path.add(0, this.now);\r\n        while (this.now.x != this.xstart || this.now.y != this.ystart) {\r\n            this.now = this.now.parent;\r\n            this.path.add(0, this.now);\r\n        }\r\n        return this.path;\r\n    }\r\n    /*\r\n    ** Looks in a given List<> for a node\r\n    **\r\n    ** @return (bool) NeightborInListFound\r\n    */\r\n    private static boolean findNeighborInList(List<Node> array, Node node) {\r\n        return array.stream().anyMatch((n) -> (n.x == node.x && n.y == node.y));\r\n    }\r\n    /*\r\n    ** Calulate distance between this.now and xend/yend\r\n    **\r\n    ** @return (int) distance\r\n    */\r\n    private double distance(int dx, int dy) {\r\n        if (this.diag) { // if diagonal movement is alloweed\r\n            return Math.hypot(this.now.x + dx - this.xend, this.now.y + dy - this.yend); // return hypothenuse\r\n        } else {\r\n            return Math.abs(this.now.x + dx - this.xend) + Math.abs(this.now.y + dy - this.yend); // else return \"Manhattan distance\"\r\n        }\r\n    }\r\n    private void addNeigborsToOpenList() {\r\n        Node node;\r\n        for (int x = -1; x <= 1; x++) {\r\n            for (int y = -1; y <= 1; y++) {\r\n                if (!this.diag && x != 0 && y != 0) {\r\n                    continue; // skip if diagonal movement is not allowed\r\n                }\r\n                node = new Node(this.now, this.now.x + x, this.now.y + y, this.now.g, this.distance(x, y));\r\n                if ((x != 0 || y != 0) // not this.now\r\n                    && this.now.x + x >= 0 && this.now.x + x < this.maze[0].length // check maze boundaries\r\n                    && this.now.y + y >= 0 && this.now.y + y < this.maze.length\r\n                    && this.maze[this.now.y + y][this.now.x + x] != -1 // check if square is walkable\r\n                    && !findNeighborInList(this.open, node) && !findNeighborInList(this.closed, node)) { // if not already done\r\n                        node.g = node.parent.g + 1.; // Horizontal/vertical cost = 1.0\r\n                        node.g += maze[this.now.y + y][this.now.x + x]; // add movement cost for this square\r\n \r\n                        // diagonal cost = sqrt(hor_cost² + vert_cost²)\r\n                        // in this example the cost would be 12.2 instead of 11\r\n                        /*\r\n                        if (diag && x != 0 && y != 0) {\r\n                            node.g += .4;	// Diagonal movement cost = 1.4\r\n                        }\r\n                        */\r\n                        this.open.add(node);\r\n                }\r\n            }\r\n        }\r\n        Collections.sort(this.open);\r\n    }\r\n \r\n    public static void main(String[] args) {\r\n        // -1 = blocked\r\n        // 0+ = additional movement cost\r\n        int[][] maze = {\r\n            {  0,  0,  0,  0,  0,  0,  0'),
(10, 2, 'Bubble', 'Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.', 'bubble.gif', 'Starting from the first index, compare the first and the second elements.If the first element is greater than the second element, they are swapped.\r\n<br>\r\nNow, compare the second and the third elements. Swap them if they are not in order.\r\n<br>\r\nThe above process goes on until the last element.                               After each iteration, the largest element among the unsorted elements is placed at the end.\r\n<br>\r\nIn each iteration, the comparison takes place up to the last unsorted element.\r\n', 'def bubbleSort(arr): \r\n    n = len(arr) \r\n  \r\n    # Traverse through all array elements \r\n    for i in range(n): \r\n  \r\n        # Last i elements are already in place \r\n        for j in range(0, n-i-1): \r\n  \r\n            # traverse the array from 0 to n-i-1 \r\n            # Swap if the element found is greater \r\n            # than the next element \r\n            if arr[j] > arr[j+1] : \r\n                arr[j], arr[j+1] = arr[j+1], arr[j] \r\n  \r\n# Driver code to test above \r\narr = [64, 34, 25, 12, 22, 11, 90] \r\n  \r\nbubbleSort(arr) \r\n  \r\nprint (\"Sorted array is:\") \r\nfor i in range(len(arr)): \r\n    print (\"%d\" %arr[i]),', '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\nvoid swap(int *xp, int *yp)  \r\n{  \r\n    int temp = *xp;  \r\n    *xp = *yp;  \r\n    *yp = temp;  \r\n}  \r\n  \r\n// A function to implement bubble sort  \r\nvoid bubbleSort(int arr[], int n)  \r\n{  \r\n    int i, j;  \r\n    for (i = 0; i < n-1; i++)      \r\n      \r\n    // Last i elements are already in place  \r\n    for (j = 0; j < n-i-1; j++)  \r\n        if (arr[j] > arr[j+1])  \r\n            swap(&arr[j], &arr[j+1]);  \r\n}  \r\n  \r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\n// Driver code  \r\nint main()  \r\n{  \r\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};  \r\n    int n = sizeof(arr)/sizeof(arr[0]);  \r\n    bubbleSort(arr, n);  \r\n    cout<<\"Sorted array: \\n\";  \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  ', 'class BubbleSort \r\n{ \r\n    void bubbleSort(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i = 0; i < n-1; i++) \r\n            for (int j = 0; j < n-i-1; j++) \r\n                if (arr[j] > arr[j+1]) \r\n                { \r\n                    // swap arr[j+1] and arr[j] \r\n                    int temp = arr[j]; \r\n                    arr[j] = arr[j+1]; \r\n                    arr[j+1] = temp; \r\n                } \r\n    } \r\n  \r\n    /* Prints the array */\r\n    void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i] + \" \"); \r\n        System.out.println(); \r\n    } \r\n  \r\n    // Driver method to test above \r\n    public static void main(String args[]) \r\n    { \r\n        BubbleSort ob = new BubbleSort(); \r\n        int arr[] = {64, 34, 25, 12, 22, 11, 90}; \r\n        ob.bubbleSort(arr); \r\n        System.out.println(\"Sorted array\"); \r\n        ob.printArray(arr); \r\n    } \r\n} '),
(11, 2, 'Selection', 'The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning.', 'selection.gif', 'This sorting algorithm is an in-place comparison-based algorithm in which the list is divided into two parts, the sorted part at the left end and the unsorted part at the right end.<br> Initially, the sorted part is empty and the unsorted part is the entire list.\r\n<br>\r\nThe smallest element is selected from the unsorted array and swapped with the leftmost element, and that element becomes a part of the sorted array. This process continues moving unsorted array boundary by one element to the right.', 'import sys \r\nA = [64, 25, 12, 22, 11] \r\n  \r\n# Traverse through all array elements \r\nfor i in range(len(A)): \r\n      \r\n    # Find the minimum element in remaining  \r\n    # unsorted array \r\n    min_idx = i \r\n    for j in range(i+1, len(A)): \r\n        if A[min_idx] > A[j]: \r\n            min_idx = j \r\n              \r\n    # Swap the found minimum element with  \r\n    # the first element         \r\n    A[i], A[min_idx] = A[min_idx], A[i] \r\n  \r\n# Driver code to test above \r\nprint (\"Sorted array\") \r\nfor i in range(len(A)): \r\n    print(\"%d\" %A[i]),  ', '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\nvoid swap(int *xp, int *yp)  \r\n{  \r\n    int temp = *xp;  \r\n    *xp = *yp;  \r\n    *yp = temp;  \r\n}  \r\n  \r\nvoid selectionSort(int arr[], int n)  \r\n{  \r\n    int i, j, min_idx;  \r\n  \r\n    // One by one move boundary of unsorted subarray  \r\n    for (i = 0; i < n-1; i++)  \r\n    {  \r\n        // Find the minimum element in unsorted array  \r\n        min_idx = i;  \r\n        for (j = i+1; j < n; j++)  \r\n        if (arr[j] < arr[min_idx])  \r\n            min_idx = j;  \r\n  \r\n        // Swap the found minimum element with the first element  \r\n        swap(&arr[min_idx], &arr[i]);  \r\n    }  \r\n}  \r\n  \r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i=0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\n// Driver program to test above functions  \r\nint main()  \r\n{  \r\n    int arr[] = {64, 25, 12, 22, 11};  \r\n    int n = sizeof(arr)/sizeof(arr[0]);  \r\n    selectionSort(arr, n);  \r\n    cout << \"Sorted array: \\n\";  \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}', 'class SelectionSort \r\n{ \r\n    void sort(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n  \r\n        // One by one move boundary of unsorted subarray \r\n        for (int i = 0; i < n-1; i++) \r\n        { \r\n            // Find the minimum element in unsorted array \r\n            int min_idx = i; \r\n            for (int j = i+1; j < n; j++) \r\n                if (arr[j] < arr[min_idx]) \r\n                    min_idx = j; \r\n  \r\n            // Swap the found minimum element with the first \r\n            // element \r\n            int temp = arr[min_idx]; \r\n            arr[min_idx] = arr[i]; \r\n            arr[i] = temp; \r\n        } \r\n    } \r\n  \r\n    // Prints the array \r\n    void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i]+\" \"); \r\n        System.out.println(); \r\n    } \r\n  \r\n    // Driver code to test above \r\n    public static void main(String args[]) \r\n    { \r\n        SelectionSort ob = new SelectionSort(); \r\n        int arr[] = {64,25,12,22,11}; \r\n        ob.sort(arr); \r\n        System.out.println(\"Sorted array\"); \r\n        ob.printArray(arr); \r\n    } \r\n} ');
INSERT INTO `algo` (`algo_id`, `grp_id`, `name`, `definition`, `image`, `explaination`, `python`, `cpp`, `java`) VALUES
(12, 2, 'Insertion', 'Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part', 'insertion.gif', 'The algorithm maintains two subarrays in a given array.\r\n<br>\r\n1) The subarray which is already sorted.<br>\r\n2) Remaining subarray which is unsorted.<br>\r\n<br>\r\nIn every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray.', 'def insertionSort(arr): \r\n  \r\n    # Traverse through 1 to len(arr) \r\n    for i in range(1, len(arr)): \r\n  \r\n        key = arr[i] \r\n  \r\n        # Move elements of arr[0..i-1], that are \r\n        # greater than key, to one position ahead \r\n        # of their current position \r\n        j = i-1\r\n        while j >= 0 and key < arr[j] : \r\n                arr[j + 1] = arr[j] \r\n                j -= 1\r\n        arr[j + 1] = key \r\n  \r\n  \r\n# Driver code to test above \r\narr = [12, 11, 13, 5, 6] \r\ninsertionSort(arr) \r\nfor i in range(len(arr)): \r\n    print (\"% d\" % arr[i]) ', '#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n/* Function to sort an array using insertion sort*/\r\nvoid insertionSort(int arr[], int n)  \r\n{  \r\n    int i, key, j;  \r\n    for (i = 1; i < n; i++) \r\n    {  \r\n        key = arr[i];  \r\n        j = i - 1;  \r\n  \r\n        /* Move elements of arr[0..i-1], that are  \r\n        greater than key, to one position ahead  \r\n        of their current position */\r\n        while (j >= 0 && arr[j] > key) \r\n        {  \r\n            arr[j + 1] = arr[j];  \r\n            j = j - 1;  \r\n        }  \r\n        arr[j + 1] = key;  \r\n    }  \r\n}  \r\n  \r\n// A utility function to print an array of size n  \r\nvoid printArray(int arr[], int n)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < n; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl; \r\n}  \r\n  \r\n/* Driver code */\r\nint main()  \r\n{  \r\n    int arr[] = { 12, 11, 13, 5, 6 };  \r\n    int n = sizeof(arr) / sizeof(arr[0]);  \r\n  \r\n    insertionSort(arr, n);  \r\n    printArray(arr, n);  \r\n  \r\n    return 0;  \r\n}  ', 'class InsertionSort { \r\n    /*Function to sort array using insertion sort*/\r\n    void sort(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i = 1; i < n; ++i) { \r\n            int key = arr[i]; \r\n            int j = i - 1; \r\n  \r\n            /* Move elements of arr[0..i-1], that are \r\n               greater than key, to one position ahead \r\n               of their current position */\r\n            while (j >= 0 && arr[j] > key) { \r\n                arr[j + 1] = arr[j]; \r\n                j = j - 1; \r\n            } \r\n            arr[j + 1] = key; \r\n        } \r\n    } \r\n  \r\n    /* A utility function to print array of size n*/\r\n    static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i = 0; i < n; ++i) \r\n            System.out.print(arr[i] + \" \"); \r\n  \r\n        System.out.println(); \r\n    } \r\n  \r\n    // Driver method \r\n    public static void main(String args[]) \r\n    { \r\n        int arr[] = { 12, 11, 13, 5, 6 }; \r\n  \r\n        InsertionSort ob = new InsertionSort(); \r\n        ob.sort(arr); \r\n  \r\n        printArray(arr); \r\n    } \r\n}'),
(13, 2, 'Merge', ' Merge Sort is a Divide and Conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves', 'merge.gif', 'Merge sort keeps on dividing the list into equal halves until it can no more be divided. By definition, if it is only one element in the list, it is sorted. Then, merge sort combines the smaller sorted lists keeping the new list sorted too.\r\n<br>\r\nStep 1 ? if it is only one element in the list it is already sorted, return.<br>\r\nStep 2 ? divide the list recursively into two halves until it can no more be divided.<br>\r\nStep 3 ? merge the smaller lists into new list in sorted order.', 'def mergeSort(arr): \r\n    if len(arr) >1: \r\n        mid = len(arr)//2 # Finding the mid of the array \r\n        L = arr[:mid] # Dividing the array elements  \r\n        R = arr[mid:] # into 2 halves \r\n  \r\n        mergeSort(L) # Sorting the first half \r\n        mergeSort(R) # Sorting the second half \r\n  \r\n        i = j = k = 0\r\n          \r\n        # Copy data to temp arrays L[] and R[] \r\n        while i < len(L) and j < len(R): \r\n            if L[i] < R[j]: \r\n                arr[k] = L[i] \r\n                i+= 1\r\n            else: \r\n                arr[k] = R[j] \r\n                j+= 1\r\n            k+= 1\r\n          \r\n        # Checking if any element was left \r\n        while i < len(L): \r\n            arr[k] = L[i] \r\n            i+= 1\r\n            k+= 1\r\n          \r\n        while j < len(R): \r\n            arr[k] = R[j] \r\n            j+= 1\r\n            k+= 1\r\n  \r\n# Code to print the list \r\ndef printList(arr): \r\n    for i in range(len(arr)):         \r\n        print(arr[i], end =\" \") \r\n    print() \r\n  \r\n# driver code to test the above code \r\nif __name__ == \'__main__\': \r\n    arr = [12, 11, 13, 5, 6, 7]  \r\n    print (\"Given array is\", end =\"\\n\")  \r\n    printList(arr) \r\n    mergeSort(arr) \r\n    print(\"Sorted array is: \", end =\"\\n\") \r\n    printList(arr) ', '#include<iostream> \r\nusing namespace std; \r\n  \r\n// Merges two subarrays of arr[]. \r\n// First subarray is arr[l..m] \r\n// Second subarray is arr[m+1..r] \r\nvoid merge(int arr[], int l, int m, int r) \r\n{ \r\n    int n1 = m - l + 1; \r\n    int n2 = r - m; \r\n  \r\n    // Create temp arrays  \r\n    int L[n1], R[n2]; \r\n  \r\n    // Copy data to temp arrays L[] and R[]  \r\n    for(int i = 0; i < n1; i++) \r\n        L[i] = arr[l + i]; \r\n    for(int j = 0; j < n2; j++) \r\n        R[j] = arr[m + 1 + j]; \r\n  \r\n    // Merge the temp arrays back into arr[l..r] \r\n      \r\n    // Initial index of first subarray \r\n    int i = 0;  \r\n      \r\n    // Initial index of second subarray \r\n    int j = 0;  \r\n      \r\n    // Initial index of merged subarray \r\n    int k = l; \r\n      \r\n    while (i < n1 && j < n2) \r\n    { \r\n        if (L[i] <= R[j])  \r\n        { \r\n            arr[k] = L[i]; \r\n            i++; \r\n        } \r\n        else \r\n        { \r\n            arr[k] = R[j]; \r\n            j++; \r\n        } \r\n        k++; \r\n    } \r\n  \r\n    // Copy the remaining elements of \r\n    // L[], if there are any  \r\n    while (i < n1)  \r\n    { \r\n        arr[k] = L[i]; \r\n        i++; \r\n        k++; \r\n    } \r\n  \r\n    // Copy the remaining elements of \r\n    // R[], if there are any  \r\n    while (j < n2) \r\n    { \r\n        arr[k] = R[j]; \r\n        j++; \r\n        k++; \r\n    } \r\n} \r\n  \r\n// l is for left index and r is  \r\n// right index of the sub-array \r\n// of arr to be sorted */ \r\nvoid mergeSort(int arr[], int l, int r) \r\n{ \r\n    if (l < r) \r\n    { \r\n          \r\n        // Same as (l+r)/2, but avoids  \r\n        // overflow for large l and h \r\n        int m = l + (r - l) / 2; \r\n  \r\n        // Sort first and second halves \r\n        mergeSort(arr, l, m); \r\n        mergeSort(arr, m + 1, r); \r\n  \r\n        merge(arr, l, m, r); \r\n    } \r\n} \r\n  \r\n// UTILITY FUNCTIONS  \r\n// Function to print an array  \r\nvoid printArray(int A[], int size) \r\n{ \r\n    for(int i = 0; i < size; i++) \r\n        cout << A[i] << \" \"; \r\n} \r\n  \r\n// Driver code \r\n', 'class MergeSort { \r\n    // Merges two subarrays of arr[]. \r\n    // First subarray is arr[l..m] \r\n    // Second subarray is arr[m+1..r] \r\n    void merge(int arr[], int l, int m, int r) \r\n    { \r\n        // Find sizes of two subarrays to be merged \r\n        int n1 = m - l + 1; \r\n        int n2 = r - m; \r\n  \r\n        /* Create temp arrays */\r\n        int L[] = new int[n1]; \r\n        int R[] = new int[n2]; \r\n  \r\n        /*Copy data to temp arrays*/\r\n        for (int i = 0; i < n1; ++i) \r\n            L[i] = arr[l + i]; \r\n        for (int j = 0; j < n2; ++j) \r\n            R[j] = arr[m + 1 + j]; \r\n  \r\n        /* Merge the temp arrays */\r\n  \r\n        // Initial indexes of first and second subarrays \r\n        int i = 0, j = 0; \r\n  \r\n        // Initial index of merged subarry array \r\n        int k = l; \r\n        while (i < n1 && j < n2) { \r\n            if (L[i] <= R[j]) { \r\n                arr[k] = L[i]; \r\n                i++; \r\n            } \r\n            else { \r\n                arr[k] = R[j]; \r\n                j++; \r\n            } \r\n            k++; \r\n        } \r\n  \r\n        /* Copy remaining elements of L[] if any */\r\n        while (i < n1) { \r\n            arr[k] = L[i]; \r\n            i++; \r\n            k++; \r\n        } \r\n  \r\n        /* Copy remaining elements of R[] if any */\r\n        while (j < n2) { \r\n            arr[k] = R[j]; \r\n            j++; \r\n            k++; \r\n        } \r\n    } \r\n  \r\n    // Main function that sorts arr[l..r] using \r\n    // merge() \r\n    void sort(int arr[], int l, int r) \r\n    { \r\n        if (l < r) { \r\n            // Find the middle point \r\n            int m = (l + r) / 2; \r\n  \r\n            // Sort first and second halves \r\n            sort(arr, l, m); \r\n            sort(arr, m + 1, r); \r\n  \r\n            // Merge the sorted halves \r\n            merge(arr, l, m, r); \r\n        } \r\n    } \r\n  \r\n    /* A utility function to print array of size n */\r\n    static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i = 0;'),
(14, 2, 'Quick', 'Quick sort is a highly efficient sorting algorithm and is based on partitioning of array of data into smaller arrays. A large array is partitioned into two arrays one of which holds values smaller than the specified value, say pivot, based on which the partition is made and another array holds values greater than the pivot value', 'quick.gif', 'Quick Sort Algorithm is as follows <br>Step 1 -Choose the highest index value has pivot<br>\r\nStep 2 - Take two variables to point left and right of the list excluding pivot<br>\r\nStep 3 - left points to the low index<br>\r\nStep 4 - right points to the high<br>\r\nStep 5 - while value at left is less than pivot move right<br>\r\nStep 6 - while value at right is greater than pivot move left<br>\r\nStep 7 - if both step 5 and step 6 does not match swap left and right<br>\r\nStep 8 -if left - right, the point where they met is new pivot', 'def partition(arr,low,high): \r\n    i = ( low-1 )         # index of smaller element \r\n    pivot = arr[high]     # pivot \r\n  \r\n    for j in range(low , high): \r\n  \r\n        # If current element is smaller than the pivot \r\n        if   arr[j] < pivot: \r\n          \r\n            # increment index of smaller element \r\n            i = i+1 \r\n            arr[i],arr[j] = arr[j],arr[i] \r\n  \r\n    arr[i+1],arr[high] = arr[high],arr[i+1] \r\n    return ( i+1 ) \r\n  \r\n# The main function that implements QuickSort \r\n# arr[] --> Array to be sorted, \r\n# low  --> Starting index, \r\n# high  --> Ending index \r\n  \r\n# Function to do Quick sort \r\ndef quickSort(arr,low,high): \r\n    if low < high: \r\n  \r\n        # pi is partitioning index, arr[p] is now \r\n        # at right place \r\n        pi = partition(arr,low,high) \r\n  \r\n        # Separately sort elements before \r\n        # partition and after partition \r\n        quickSort(arr, low, pi-1) \r\n        quickSort(arr, pi+1, high) \r\n  \r\n# Driver code to test above \r\narr = [10, 7, 8, 9, 1, 5] \r\nn = len(arr) \r\nquickSort(arr,0,n-1) \r\nprint (\"Sorted array is:\") \r\nfor i in range(n): \r\n    print (\"%d\" %arr[i]), ', '#include <bits/stdc++.h> \r\nusing namespace std;  \r\n  \r\n// A utility function to swap two elements  \r\nvoid swap(int* a, int* b)  \r\n{  \r\n    int t = *a;  \r\n    *a = *b;  \r\n    *b = t;  \r\n}  \r\n  \r\n/* This function takes last element as pivot, places  \r\nthe pivot element at its correct position in sorted  \r\narray, and places all smaller (smaller than pivot)  \r\nto left of pivot and all greater elements to right  \r\nof pivot */\r\nint partition (int arr[], int low, int high)  \r\n{  \r\n    int pivot = arr[high]; // pivot  \r\n    int i = (low - 1); // Index of smaller element  \r\n  \r\n    for (int j = low; j <= high - 1; j++)  \r\n    {  \r\n        // If current element is smaller than the pivot  \r\n        if (arr[j] < pivot)  \r\n        {  \r\n            i++; // increment index of smaller element  \r\n            swap(&arr[i], &arr[j]);  \r\n        }  \r\n    }  \r\n    swap(&arr[i + 1], &arr[high]);  \r\n    return (i + 1);  \r\n}  \r\n  \r\n/* The main function that implements QuickSort  \r\narr[] --> Array to be sorted,  \r\nlow --> Starting index,  \r\nhigh --> Ending index */\r\nvoid quickSort(int arr[], int low, int high)  \r\n{  \r\n    if (low < high)  \r\n    {  \r\n        /* pi is partitioning index, arr[p] is now  \r\n        at right place */\r\n        int pi = partition(arr, low, high);  \r\n  \r\n        // Separately sort elements before  \r\n        // partition and after partition  \r\n        quickSort(arr, low, pi - 1);  \r\n        quickSort(arr, pi + 1, high);  \r\n    }  \r\n}  \r\n  \r\n/* Function to print an array */\r\nvoid printArray(int arr[], int size)  \r\n{  \r\n    int i;  \r\n    for (i = 0; i < size; i++)  \r\n        cout << arr[i] << \" \";  \r\n    cout << endl;  \r\n}  \r\n  \r\n// Driver Code \r\nint main()  \r\n{  \r\n    int arr[] = {10, 7, 8, 9, 1, 5};  \r\n    int n = sizeof(arr) / sizeof(arr[0]);  \r\n    quickSort(arr, 0, n - 1);  \r\n    cout << \"Sorted array: \\n\";  \r\n    printArray(arr, n);  \r\n    return 0;  \r\n}  ', 'class QuickSort \r\n{ \r\n    /* This function takes last element as pivot, \r\n       places the pivot element at its correct \r\n       position in sorted array, and places all \r\n       smaller (smaller than pivot) to left of \r\n       pivot and all greater elements to right \r\n       of pivot */\r\n    int partition(int arr[], int low, int high) \r\n    { \r\n        int pivot = arr[high];  \r\n        int i = (low-1); // index of smaller element \r\n        for (int j=low; j<high; j++) \r\n        { \r\n            // If current element is smaller than the pivot \r\n            if (arr[j] < pivot) \r\n            { \r\n                i++; \r\n  \r\n                // swap arr[i] and arr[j] \r\n                int temp = arr[i]; \r\n                arr[i] = arr[j]; \r\n                arr[j] = temp; \r\n            } \r\n        } \r\n  \r\n        // swap arr[i+1] and arr[high] (or pivot) \r\n        int temp = arr[i+1]; \r\n        arr[i+1] = arr[high]; \r\n        arr[high] = temp; \r\n  \r\n        return i+1; \r\n    } \r\n  \r\n  \r\n    /* The main function that implements QuickSort() \r\n      arr[] --> Array to be sorted, \r\n      low  --> Starting index, \r\n      high  --> Ending index */\r\n    void sort(int arr[], int low, int high) \r\n    { \r\n        if (low < high) \r\n        { \r\n            /* pi is partitioning index, arr[pi] is  \r\n              now at right place */\r\n            int pi = partition(arr, low, high); \r\n  \r\n            // Recursively sort elements before \r\n            // partition and after partition \r\n            sort(arr, low, pi-1); \r\n            sort(arr, pi+1, high); \r\n        } \r\n    } \r\n  \r\n    /* A utility function to print array of size n */\r\n    static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i]+\" \"); \r\n        System.out.println(); \r\n    } \r\n  \r\n    // Driver program \r\n    public static void main(String args[]) \r\n    { \r\n        int arr[] = {10, 7, 8, 9, 1, 5}; \r\n        int n = arr.length; \r\n  \r\n        QuickSort ob = new QuickSort(); \r\n        ob.sort(arr, 0, n-1); \r\n  \r\n        System.out.println(\"sorted array\"); \r\n        printArray(arr); \r\n    } \r\n} '),
(15, 2, 'Heap', 'Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end', 'heap.gif', 'Here there are steps  to implement Heap Sort <br>1. Build a max heap from the input data.<br>\r\n2. At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of the tree.<br>\r\n3. Repeat step 2 while size of heap is greater than ', 'def heapify(arr, n, i): \r\n    largest = i # Initialize largest as root \r\n    l = 2 * i + 1     # left = 2*i + 1 \r\n    r = 2 * i + 2     # right = 2*i + 2 \r\n  \r\n    # See if left child of root exists and is \r\n    # greater than root \r\n    if l < n and arr[i] < arr[l]: \r\n        largest = l \r\n  \r\n    # See if right child of root exists and is \r\n    # greater than root \r\n    if r < n and arr[largest] < arr[r]: \r\n        largest = r \r\n  \r\n    # Change root, if needed \r\n    if largest != i: \r\n        arr[i],arr[largest] = arr[largest],arr[i] # swap \r\n  \r\n        # Heapify the root. \r\n        heapify(arr, n, largest) \r\n  \r\n# The main function to sort an array of given size \r\ndef heapSort(arr): \r\n    n = len(arr) \r\n  \r\n    # Build a maxheap. \r\n    for i in range(n//2 - 1, -1, -1): \r\n        heapify(arr, n, i) \r\n  \r\n    # One by one extract elements \r\n    for i in range(n-1, 0, -1): \r\n        arr[i], arr[0] = arr[0], arr[i] # swap \r\n        heapify(arr, i, 0) \r\n  \r\n# Driver code to test above \r\narr = [ 12, 11, 13, 5, 6, 7] \r\nheapSort(arr) \r\nn = len(arr) \r\nprint (\"Sorted array is\") \r\nfor i in range(n): \r\n    print (\"%d\" %arr[i]),', '#include <iostream> \r\n  \r\nusing namespace std; \r\n  \r\n// To heapify a subtree rooted with node i which is \r\n// an index in arr[]. n is size of heap \r\nvoid heapify(int arr[], int n, int i) \r\n{ \r\n    int largest = i; // Initialize largest as root \r\n    int l = 2*i + 1; // left = 2*i + 1 \r\n    int r = 2*i + 2; // right = 2*i + 2 \r\n  \r\n    // If left child is larger than root \r\n    if (l < n && arr[l] > arr[largest]) \r\n        largest = l; \r\n  \r\n    // If right child is larger than largest so far \r\n    if (r < n && arr[r] > arr[largest]) \r\n        largest = r; \r\n  \r\n    // If largest is not root \r\n    if (largest != i) \r\n    { \r\n        swap(arr[i], arr[largest]); \r\n  \r\n        // Recursively heapify the affected sub-tree \r\n        heapify(arr, n, largest); \r\n    } \r\n} \r\n  \r\n// main function to do heap sort \r\nvoid heapSort(int arr[], int n) \r\n{ \r\n    // Build heap (rearrange array) \r\n    for (int i = n / 2 - 1; i >= 0; i--) \r\n        heapify(arr, n, i); \r\n  \r\n    // One by one extract an element from heap \r\n    for (int i=n-1; i>0; i--) \r\n    { \r\n        // Move current root to end \r\n        swap(arr[0], arr[i]); \r\n  \r\n        // call max heapify on the reduced heap \r\n        heapify(arr, i, 0); \r\n    } \r\n} \r\n  \r\n/* A utility function to print array of size n */\r\nvoid printArray(int arr[], int n) \r\n{ \r\n    for (int i=0; i<n; ++i) \r\n        cout << arr[i] << \" \"; \r\n    cout << \"\\n\"; \r\n} \r\n  \r\n// Driver program \r\nint main() \r\n{ \r\n    int arr[] = {12, 11, 13, 5, 6, 7}; \r\n    int n = sizeof(arr)/sizeof(arr[0]); \r\n  \r\n    heapSort(arr, n); \r\n  \r\n    cout << \"Sorted array is \\n\"; \r\n    printArray(arr, n); \r\n} ', 'public class HeapSort \r\n{ \r\n    public void sort(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n  \r\n        // Build heap (rearrange array) \r\n        for (int i = n / 2 - 1; i >= 0; i--) \r\n            heapify(arr, n, i); \r\n  \r\n        // One by one extract an element from heap \r\n        for (int i=n-1; i>0; i--) \r\n        { \r\n            // Move current root to end \r\n            int temp = arr[0]; \r\n            arr[0] = arr[i]; \r\n            arr[i] = temp; \r\n  \r\n            // call max heapify on the reduced heap \r\n            heapify(arr, i, 0); \r\n        } \r\n    } \r\n  \r\n    // To heapify a subtree rooted with node i which is \r\n    // an index in arr[]. n is size of heap \r\n    void heapify(int arr[], int n, int i) \r\n    { \r\n        int largest = i; // Initialize largest as root \r\n        int l = 2*i + 1; // left = 2*i + 1 \r\n        int r = 2*i + 2; // right = 2*i + 2 \r\n  \r\n        // If left child is larger than root \r\n        if (l < n && arr[l] > arr[largest]) \r\n            largest = l; \r\n  \r\n        // If right child is larger than largest so far \r\n        if (r < n && arr[r] > arr[largest]) \r\n            largest = r; \r\n  \r\n        // If largest is not root \r\n        if (largest != i) \r\n        { \r\n            int swap = arr[i]; \r\n            arr[i] = arr[largest]; \r\n            arr[largest] = swap; \r\n  \r\n            // Recursively heapify the affected sub-tree \r\n            heapify(arr, n, largest); \r\n        } \r\n    } \r\n  \r\n    /* A utility function to print array of size n */\r\n    static void printArray(int arr[]) \r\n    { \r\n        int n = arr.length; \r\n        for (int i=0; i<n; ++i) \r\n            System.out.print(arr[i]+\" \"); \r\n        System.out.println(); \r\n    } \r\n  \r\n    // Driver program \r\n    public static void main(String args[]) \r\n    { \r\n        int arr[] = {12, 11, 13, 5, 6, 7}; \r\n        int n = arr.length; \r\n  \r\n        HeapSort ob = new HeapSort(); \r\n        ob.sort(arr); \r\n  \r\n        System.out.println(\"Sorted array is\"); \r\n        printArray(arr); \r\n    } \r\n} '),
(23, 3, 'Linear', 'In computer science, a linear search or sequential search is a method for finding an element within a list. It sequentially checks each element of the list until a match is found or the whole list has been searched.', 'linear.gif', 'A simple approach is to do linear search, i.e <br>\r\n<ol style=\"padding-left:17px\">\r\n		<li> Start from the leftmost element of arr[] and one by one compare x with each element of arr[]</li>\r\n		<li> If x matches with an element, return the index.</li>\r\n		<li> If x doesn’t match with any of elements, return -1..</li>\r\n				</ol>', 'def search(arr, n, x): \r\n		\r\n	for i in range (0, n): \r\n		if (arr[i] == x): \r\n			return i; \r\n	return -1; \r\n		\r\n# Driver Code \r\narr = [ 2, 3, 4, 10, 40 ]; \r\nx = 10; \r\nn = len(arr); \r\nresult = search(arr, n, x) \r\nif(result == -1): \r\n	print(\"Element is not present in array\") \r\nelse: \r\n	print(\"Element is present at \", result); ', '#include < iostream > \r\nusing namespace std; \r\n		\r\nint search(int arr[], int n, int x) \r\n{ \r\n	int i; \r\n	for (i = 0; i < n; i++) \r\n		if (arr[i] == x) \r\n			return i; \r\n	return -1; \r\n} \r\n		\r\nint main(void) \r\n{ \r\n	int arr[] = { 2, 3, 4, 10, 40 }; \r\n	int x = 10; \r\n	int n = sizeof(arr) / sizeof(arr[0]); \r\n	int result = search(arr, n, x); \r\nif (result == -1) {\r\n	cout<<\"Element is not present in array\";\r\n}	\r\nelse{\r\n	cout<<\"Element is present at \"+result;\r\n} \r\nreturn 0; \r\n}', 'class GFG \r\n		{ \r\npublic static int search(int arr[], int x) \r\n{ \r\n	int n = arr.length; \r\n		for(int i = 0; i < n; i++) \r\n	{ \r\n		if(arr[i] == x) \r\n			return i; \r\n	} \r\n	return -1; \r\n} \r\n		\r\npublic static void main(String args[]) \r\n{ \r\n	int arr[] = { 2, 3, 4, 10, 40 }; \r\n	int x = 10; \r\n	int result = search(arr, x); \r\nif(result == -1) \r\n	System.out.print(\"Element not found\"); \r\nelse\r\n	System.out.print(\"Element is at \" +result); \r\n	 \r\n} \r\n}'),
(24, 3, 'Jump', 'Like Binary Search, Jump Search is a searching algorithm for sorted arrays. The basic idea is to check fewer elements (than linear search)by jumping ahead by fixed steps or skipping some elements in place of searching all elements.', 'jump.gif', 'Lets consider a sorted array A[] of size n, with indexing ranging between 0 and n-1, and element x that needs to be searched in the array A[] of block size m.<br>  <br> Thus, the algorithm works as follows: <br> Iteration 1: if (x==A[0]), then success, else, if (x > A[0]), then jump to the next block.<br> Iteration 2: if (x==A[m]), then success, else, if (x > A[m]), then jump to the next block.<br> Iteration 3: if (x==A[2m]), then success, else, if (x > A[2m]), then jump to the next block.<br> At any point in time, if(x < A[km]), then a linear search is performed from index A[(k-1)m] to A[km]\r\n', 'import math \r\n  \r\ndef jumpSearch( arr , x , n ): \r\n      \r\n    # Finding block size to be jumped \r\n    step = math.sqrt(n) \r\n      \r\n    # Finding the block where element is \r\n    # present (if it is present) \r\n    prev = 0\r\n    while arr[int(min(step, n)-1)] < x: \r\n        prev = step \r\n        step += math.sqrt(n) \r\n        if prev >= n: \r\n            return -1\r\n      \r\n    # Doing a linear search for x in  \r\n    # block beginning with prev. \r\n    while arr[int(prev)] < x: \r\n        prev += 1\r\n          \r\n        # If we reached next block or end  \r\n        # of array, element is not present. \r\n        if prev == min(step, n): \r\n            return -1\r\n      \r\n    # If element is found \r\n    if arr[int(prev)] == x: \r\n        return prev \r\n      \r\n    return -1\r\n  \r\n\r\n', '// C++ program to implement Jump Search \r\n  \r\n#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\nint jumpSearch(int arr[], int x, int n) \r\n{ \r\n    // Finding block size to be jumped \r\n    int step = sqrt(n); \r\n  \r\n    // Finding the block where element is \r\n    // present (if it is present) \r\n    int prev = 0; \r\n    while (arr[min(step, n)-1] < x) \r\n    { \r\n        prev = step; \r\n        step += sqrt(n); \r\n        if (prev >= n) \r\n            return -1; \r\n    } \r\n  \r\n    // Doing a linear search for x in block \r\n    // beginning with prev. \r\n    while (arr[prev] < x) \r\n    { \r\n        prev++; \r\n  \r\n        // If we reached next block or end of \r\n        // array, element is not present. \r\n        if (prev == min(step, n)) \r\n            return -1; \r\n    } \r\n    // If element is found \r\n    if (arr[prev] == x) \r\n        return prev; \r\n  \r\n    return -1; \r\n} \r\n\r\n', 'public class JumpSearch \r\n{ \r\n    public static int jumpSearch(int[] arr, int x) \r\n    { \r\n        int n = arr.length; \r\n  \r\n        // Finding block size to be jumped \r\n        int step = (int)Math.floor(Math.sqrt(n)); \r\n  \r\n        // Finding the block where element is \r\n        // present (if it is present) \r\n        int prev = 0; \r\n        while (arr[Math.min(step, n)-1] < x) \r\n        { \r\n            prev = step; \r\n            step += (int)Math.floor(Math.sqrt(n)); \r\n            if (prev >= n) \r\n                return -1; \r\n        } \r\n  \r\n        // Doing a linear search for x in block \r\n        // beginning with prev. \r\n        while (arr[prev] < x) \r\n        { \r\n            prev++; \r\n  \r\n            // If we reached next block or end of \r\n            // array, element is not present. \r\n            if (prev == Math.min(step, n)) \r\n                return -1; \r\n        } \r\n  \r\n        // If element is found \r\n        if (arr[prev] == x) \r\n            return prev; \r\n  \r\n        return -1; \r\n    } '),
(25, 3, 'Binary', 'Binary Search is applied on the sorted array or list of large size. It\'s time complexity of O(log n) makes it very fast as compared to other sorting algorithms. The only limitation is that the array or list of elements must be sorted for the binary search algorithm to work on it.', 'binary.gif', 'Here are the steps to follow binary search <br><br>Start with the middle element:<br>\r\nIf the target value is equal to the middle element of the array, then return the index of the middle element.<br>\r\nIf not, then compare the middle element with the target value,<br>\r\n1.  If the target value is greater than the number in the middle index, then pick the elements to the right of the middle index, and start with Step 1<br>\r\n2.  If the target value is less than the number in the middle index, then pick the elements to the left of the middle index, and start with Step 1<br><br>\r\nWhen a match is found, return the index of the element matched.<br>\r\nIf no match is found, then return -1\r\n', '# Returns index of x in arr if present, else -1 \r\ndef binarySearch (arr, l, r, x): \r\n  \r\n    # Check base case \r\n    if r >= l: \r\n  \r\n        mid = l + (r - l) // 2\r\n  \r\n        # If element is present at the middle itself \r\n        if arr[mid] == x: \r\n            return mid \r\n          \r\n        # If element is smaller than mid, then it  \r\n        # can only be present in left subarray \r\n        elif arr[mid] > x: \r\n            return binarySearch(arr, l, mid-1, x) \r\n  \r\n        # Else the element can only be present  \r\n        # in right subarray \r\n        else: \r\n            return binarySearch(arr, mid + 1, r, x) \r\n  \r\n    else: \r\n        # Element is not present in the array \r\n        return -1\r\n  \r\n# Driver Code \r\narr = [ 2, 3, 4, 10, 40 ] \r\nx = 10\r\n  \r\n# Function call \r\nresult = binarySearch(arr, 0, len(arr)-1, x) \r\n  \r\nif result != -1: \r\n    print (\"Element is present at index % d\" % result) \r\nelse: \r\n    print (\"Element is not present in array\")', '\r\n// C++ program to implement recursive Binary Search \r\n#include <bits/stdc++.h> \r\nusing namespace std; \r\n  \r\n// A recursive binary search function. It returns \r\n// location of x in given array arr[l..r] is present, \r\n// otherwise -1 \r\nint binarySearch(int arr[], int l, int r, int x) \r\n{ \r\n    if (r >= l) { \r\n        int mid = l + (r - l) / 2; \r\n  \r\n        // If the element is present at the middle \r\n        // itself \r\n        if (arr[mid] == x) \r\n            return mid; \r\n  \r\n        // If element is smaller than mid, then \r\n        // it can only be present in left subarray \r\n        if (arr[mid] > x) \r\n            return binarySearch(arr, l, mid - 1, x); \r\n  \r\n        // Else the element can only be present \r\n        // in right subarray \r\n        return binarySearch(arr, mid + 1, r, x); \r\n    } \r\n  \r\n    // We reach here when element is not \r\n    // present in array \r\n    return -1; \r\n} \r\n  \r\nint main(void) \r\n{ \r\n    int arr[] = { 2, 3, 4, 10, 40 }; \r\n    int x = 10; \r\n    int n = sizeof(arr) / sizeof(arr[0]); \r\n    int result = binarySearch(arr, 0, n - 1, x); \r\n    (result == -1) ? cout << \"Element is not present in array\"\r\n                   : cout << \"Element is present at index \" << result; \r\n    return 0; \r\n} ', '\r\n// Java implementation of recursive Binary Search \r\nclass BinarySearch { \r\n    // Returns index of x if it is present in arr[l.. \r\n    // r], else return -1 \r\n    int binarySearch(int arr[], int l, int r, int x) \r\n    { \r\n        if (r >= l) { \r\n            int mid = l + (r - l) / 2; \r\n  \r\n            // If the element is present at the \r\n            // middle itself \r\n            if (arr[mid] == x) \r\n                return mid; \r\n  \r\n            // If element is smaller than mid, then \r\n            // it can only be present in left subarray \r\n            if (arr[mid] > x) \r\n                return binarySearch(arr, l, mid - 1, x); \r\n  \r\n            // Else the element can only be present \r\n            // in right subarray \r\n            return binarySearch(arr, mid + 1, r, x); \r\n        } \r\n  \r\n        // We reach here when element is not present \r\n        // in array \r\n        return -1; \r\n    }'),
(26, 3, 'Exponential', 'Exponential Search also known as finger search, searches for an element in a sorted array by jumping 2^i elements every iteration where i represents the value of loop control variable, and then verifying if the search element is present between last jump and the current jump.', 'exponent.gif', 'Exponential search involves two steps:  \r\n<br>\r\n1. Find range where element is present\r\n2. Do Binary Search in above found range.\r\n<br><br>\r\nThe idea is to start with subarray size 1, compare its last element with x, then try size 2, then 4 and so on until last element of a subarray is not greater. \r\nOnce we find an index i (after repeated doubling of i), we know that the element must be present between i/2 and i (Why i/2? because we could not find a greater value in previous iteration)\r\nGiven below are the implementations of above steps.', 'def binarySearch( arr, l, r, x):\r\n    if r >= l:\r\n        mid = l + ( r-l ) / 2\r\n         \r\n        # If the element is present at \r\n        # the middle itself\r\n        if arr[mid] == x:\r\n            return mid\r\n         \r\n        # If the element is smaller than mid, \r\n        # then it can only be present in the \r\n        # left subarray\r\n        if arr[mid] > x:\r\n            return binarySearch(arr, l, \r\n                                mid - 1, x)\r\n         \r\n        # Else he element can only be\r\n        # present in the right\r\n        return binarySearch(arr, mid + 1, r, x)\r\n         \r\n    # We reach here if the element is not present\r\n    return -1\r\n \r\n# Returns the position of first\r\n# occurrence of x in array\r\ndef exponentialSearch(arr, n, x):\r\n    # IF x is present at first \r\n    # location itself\r\n    if arr[0] == x:\r\n        return 0\r\n         \r\n    # Find range for binary search \r\n    # j by repeated doubling\r\n    i = 1\r\n    while i < n and arr[i] <= x:\r\n        i = i * 2\r\n     \r\n    # Call binary search for the found range\r\n    return binarySearch( arr, i / 2, \r\n                         min(i, n-1), x)\r\n     \r\n \r\n# Driver Code\r\narr = [2, 3, 4, 10, 40]\r\nn = len(arr)\r\nx = 10\r\nresult = exponentialSearch(arr, n, x)\r\nif result == -1:\r\n    print \"Element not found in thye array\"\r\nelse:\r\n    print \"Element is present at index %d\" %(result)', '#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\nint binarySearch(int arr[], int, int, int);\r\n \r\n// Returns position of first occurrence of\r\n// x in array\r\nint exponentialSearch(int arr[], int n, int x)\r\n{\r\n    // If x is present at firt location itself\r\n    if (arr[0] == x)\r\n        return 0;\r\n \r\n    // Find range for binary search by\r\n    // repeated doubling\r\n    int i = 1;\r\n    while (i < n && arr[i] <= x)\r\n        i = i*2;\r\n \r\n    //  Call binary search for the found range.\r\n    return binarySearch(arr, i/2, \r\n                            min(i, n-1), x);\r\n}\r\n \r\n// A recursive binary search function. It returns\r\n// location of x in  given array arr[l..r] is\r\n// present, otherwise -1\r\nint binarySearch(int arr[], int l, int r, int x)\r\n{\r\n    if (r >= l)\r\n    {\r\n        int mid = l + (r - l)/2;\r\n \r\n        // If the element is present at the middle\r\n        // itself\r\n        if (arr[mid] == x)\r\n            return mid;\r\n \r\n        // If element is smaller than mid, then it\r\n        // can only be present n left subarray\r\n        if (arr[mid] > x)\r\n            return binarySearch(arr, l, mid-1, x);\r\n \r\n        // Else the element can only be present\r\n        // in right subarray\r\n        return binarySearch(arr, mid+1, r, x);\r\n    }\r\n \r\n    // We reach here when element is not present\r\n    // in array\r\n    return -1;\r\n}\r\n \r\n// Driver code\r\nint main(void)\r\n{\r\n   int arr[] = {2, 3, 4, 10, 40};\r\n   int n = sizeof(arr)/ sizeof(arr[0]);\r\n   int x = 10;\r\n   int result = exponentialSearch(arr, n, x);\r\n   (result == -1)? printf(\"Element is not \r\n                            present in array\")\r\n                 : printf(\"Element is present \r\n                                 at index %d\",\r\n                                       result);\r\n   return 0;\r\n}', 'import java.util.Arrays;\r\n \r\nclass GFG\r\n{\r\n    // Returns position of \r\n    // first occurrence of\r\n    // x in array\r\n    static int exponentialSearch(int arr[],\r\n                                 int n, int x)\r\n    {\r\n        // If x is present at firt location itself\r\n        if (arr[0] == x)\r\n            return 0;\r\n     \r\n        // Find range for binary search by\r\n        // repeated doubling\r\n        int i = 1;\r\n        while (i < n && arr[i] <= x)\r\n            i = i*2;\r\n     \r\n        // Call binary search for the found range.\r\n        return Arrays.binarySearch(arr, i/2, \r\n                              Math.min(i, n-1), x);\r\n    }\r\n     \r\n    // Driver code\r\n    public static void main(String args[])\r\n    {\r\n        int arr[] = {2, 3, 4, 10, 40};\r\n        int x = 10;\r\n        int result = exponentialSearch(arr, \r\n                                  arr.length, x);\r\n         \r\n        System.out.println((result < 0) ? \r\n          \"Element is not present in array\" :\r\n          \"Element is present at index \" + \r\n                             result);\r\n    }\r\n}');

-- --------------------------------------------------------

--
-- Table structure for table `auth`
--

CREATE TABLE `auth` (
  `user_id` int(11) NOT NULL,
  `name` varchar(30) NOT NULL,
  `email` varchar(30) NOT NULL,
  `password` varchar(30) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- Dumping data for table `auth`
--

INSERT INTO `auth` (`user_id`, `name`, `email`, `password`) VALUES
(3, 'Ansh Mitesh Chhadva', 'anshmiteshchhadva@gmail.com', 'n8PB9w=='),
(4, 'admin', 'admin@gmail.com', 'm8bf5+Y='),
(9, 'Abhishek Gupta', 'abhig0209@gmail.com', 'user_logged_in_via_google'),
(10, 'int main', 'intmain1221@gmail.com', 'user_logged_in_via_google'),
(11, 'callback warriors', 'callbackwarriors@gmail.com', 'user_logged_in_via_google'),
(12, 'Ansh Mitesh Chhadva', 'random@gmail.com', 'mw=='),
(13, 'Ansh Mitesh Chhadva', 'ansh@gmail.com', 'gg==');

-- --------------------------------------------------------

--
-- Table structure for table `bookmark`
--

CREATE TABLE `bookmark` (
  `bookmark_id` int(11) NOT NULL,
  `users_id` int(11) NOT NULL,
  `algo_id` longblob NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Dumping data for table `bookmark`
--

INSERT INTO `bookmark` (`bookmark_id`, `users_id`, `algo_id`) VALUES
(19, 3, 0x613a323a7b693a303b733a323a223130223b693a313b733a313a2231223b7d),
(20, 11, 0x613a303a7b7d),
(21, 10, 0x613a313a7b693a303b733a323a223233223b7d);

-- --------------------------------------------------------

--
-- Table structure for table `course`
--

CREATE TABLE `course` (
  `course_completion` longblob NOT NULL,
  `user_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

--
-- Dumping data for table `course`
--

INSERT INTO `course` (`course_completion`, `user_id`) VALUES
(0x613a31343a7b733a333a22424653223b693a303b733a333a22444653223b693a303b733a383a2244696a6b73747261223b693a303b733a363a22412073746172223b693a303b733a363a22427562626c65223b693a303b733a393a2253656c656374696f6e223b693a303b733a393a22496e73657274696f6e223b693a303b733a353a224d65726765223b693a303b733a353a22517569636b223b693a303b733a343a2248656170223b693a303b733a363a224c696e656172223b693a303b733a343a224a756d70223b693a303b733a363a2242696e617279223b693a303b733a31313a224578706f6e656e7469616c223b693a303b7d, 10),
(0x613a31343a7b733a333a22424653223b693a303b733a333a22444653223b693a303b733a383a2244696a6b73747261223b693a303b733a363a22412073746172223b693a303b733a363a22427562626c65223b693a313b733a393a2253656c656374696f6e223b693a313b733a393a22496e73657274696f6e223b693a313b733a353a224d65726765223b693a313b733a353a22517569636b223b693a303b733a343a2248656170223b693a303b733a363a224c696e656172223b693a303b733a343a224a756d70223b693a303b733a363a2242696e617279223b693a303b733a31313a224578706f6e656e7469616c223b693a303b7d, 3),
(0x613a31343a7b733a333a22424653223b693a303b733a333a22444653223b693a303b733a383a2244696a6b73747261223b693a303b733a363a22412073746172223b693a303b733a363a22427562626c65223b693a303b733a393a2253656c656374696f6e223b693a303b733a393a22496e73657274696f6e223b693a303b733a353a224d65726765223b693a303b733a353a22517569636b223b693a303b733a343a2248656170223b693a303b733a363a224c696e656172223b693a303b733a343a224a756d70223b693a303b733a363a2242696e617279223b693a303b733a31313a224578706f6e656e7469616c223b693a303b7d, 12);

--
-- Indexes for dumped tables
--

--
-- Indexes for table `algo`
--
ALTER TABLE `algo`
  ADD PRIMARY KEY (`algo_id`);

--
-- Indexes for table `auth`
--
ALTER TABLE `auth`
  ADD PRIMARY KEY (`user_id`),
  ADD UNIQUE KEY `email` (`email`);

--
-- Indexes for table `bookmark`
--
ALTER TABLE `bookmark`
  ADD PRIMARY KEY (`bookmark_id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `algo`
--
ALTER TABLE `algo`
  MODIFY `algo_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=27;

--
-- AUTO_INCREMENT for table `auth`
--
ALTER TABLE `auth`
  MODIFY `user_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=14;

--
-- AUTO_INCREMENT for table `bookmark`
--
ALTER TABLE `bookmark`
  MODIFY `bookmark_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=22;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
